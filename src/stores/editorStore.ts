import { create } from "zustand";
import type { EditorStore, Block } from "../types/editor.types";
import { v4 as uuid } from "uuid";

// TODO: what is debouncing? and why do I need it?

export const useEditorStore = create<EditorStore>((set) => ({
    title: "",
    blocks: [
        { uuid: uuid(), content: "", type: 'paragraph' }
    ],
    activeBlockIndex: 0,

    updateTitle: (title: string) => set(() => ({ title: title })),

    // the block uuid is autogenerated
    addBlock(block: Block, afterIndex: number | null) {
        // block.uuid = uuid();
        // this could be dangerous because this line is mutating the original object
        // this could shot you in the foot if you try to add the same block twice or more
        // all blocks will have the same uuid

        const newBlock = { ...block, uuid: uuid() };

        if (afterIndex === null) {
            set((state) => {
                return { blocks: [newBlock, ...state.blocks], activeBlockIndex: 0 };
            });
        } else {
            set((state) => {
                const newBlocks = [...state.blocks];
                newBlocks.splice(afterIndex + 1, 0, newBlock);
                return { blocks: newBlocks, activeBlockIndex: afterIndex + 1 };
            });
        }
    },
    updateBlock(index: number, content: string) {
        set((state) => {
            if (!state.blocks[index])
                return state;
            state.blocks[index].content = content;
            return { blocks: [...state.blocks] };
        })
    },
    deleteBlock(index: number) {
        set((state) => {
            if (!state.blocks[index])
                return state;

            return {
                blocks: state.blocks.length <= 1
                    ? [{ uuid: uuid(), content: "", type: "paragraph" }]
                    : state.blocks.toSpliced(index, 1),
                activeBlockIndex: index > 0 ? index - 1 : 0 // one step backward
            };
        })
    },
    reorderBlocks(sourceIndex: number, destinationIndex: number) {
        const moveItem = (arr: Block[], from: number, to: number) => {
            const newArr = [...arr];
            const item = newArr.splice(from, 1)[0];
            newArr.splice(to, 0, item);
            return newArr;
        };

        set((state) => {
            const newBlocks = moveItem(state.blocks, sourceIndex, destinationIndex);
            if (state.activeBlockIndex === sourceIndex)
                return { blocks: newBlocks, activeBlockIndex: destinationIndex };
            return { blocks: newBlocks };
        });
    },
    setActiveBlock(index: number) {
        set(() => ({ activeBlockIndex: index }));
    },
    duplicateBlock(index: number) {
        set((state) => {
            const blockToDuplicate = state.blocks[index];
            if (!blockToDuplicate)
                return state;

            const duplicatedBlock = { ...blockToDuplicate, uuid: uuid() };

            const newBlocks = state.blocks
                .toSpliced(index + 1, 0, duplicatedBlock);

            return { blocks: newBlocks, activeBlockIndex: index + 1 }
        });
    },
}));
